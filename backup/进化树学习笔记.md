

本文聚焦于**进化树**的相关知识，部分内容来源于我的课堂笔记，希望能对你有所帮助 😊

---

## **1. 进化树的基本概念**

**什么是进化树？**
- **定义**：
  - 进化树是一种分支图，用于表示生物序列（DNA、RNA、蛋白质）或物种之间的进化关系。
- **目的**：
  - 研究物种分化。
  - 分析基因的同源性。
  - 预测未知基因功能。

**进化树的组成**
1. **节点**：
   - **内部节点**：表示共同祖先。
   - **叶子节点**：表示当前物种或基因。
2. **分支**：
   - 表示从一个祖先到后代的演化路径。
3. **根节点**：
   - 表示最近共同祖先（有根树特有）。
4. **长度**：
   - 分支的长度通常表示进化距离或时间。

 **进化树的类型**
1. **有根树（Rooted Tree）**：
   - 有明确的进化方向和共同祖先。
2. **无根树（Unrooted Tree）**：
   - 仅表示序列间的相对关系，没有明确方向。


## **2. 进化树的构建方法**

**2.1 距离法（Distance-Based Methods）**
- **基本思想**：
  - 计算序列间的成对距离矩阵，根据距离构建进化树。
- **常用算法**：
  1. **UPGMA（Unweighted Pair Group Method with Arithmetic Mean）**：
     - 假设分子钟（进化速率恒定），适合进化速率一致的序列。
     - 步骤：
       1. 计算序列间的成对距离矩阵。
       2. 合并最近的两个簇，更新矩阵。
       3. 递归合并直到只剩一个簇。
  2. **邻接法（Neighbor-Joining, NJ）**：
     - 不要求分子钟假设，适合更广泛的序列数据。
     - 步骤：
       1. 计算距离矩阵，构造初始树。
       2. 合并距离最近的两个节点，重新计算距离矩阵。
       3. 继续合并，直到完成。

![](https://i.ibb.co/JKdyj33/image.png)

**2.2 字符法（Character-Based Methods）**
- **基本思想**：
字符法直接基于序列的特征（如碱基位置），推导序列的演化关系，适合识别复杂的演化特征。



**算法 1：最大简约法（Maximum Parsimony, MP）**

**假设**
- 假设最优进化树是发生演化变化最少的树。
- 演化变化包括碱基替换、插入、缺失等。

**步骤**
1. **定义变化成本**：每个碱基或氨基酸的替换、插入或缺失有固定成本。

2. **计算总变化**：针对每棵可能的树，计算所需的总变化。

3. **选择最优树**：总变化最少的树为最优解。


**优点**：简单直接，适合小规模序列。
**缺点**：
对长序列或高变异序列不适用。
可能有多个等优解。



**算法 2：最大似然法（Maximum Likelihood, ML）**

**假设**
- 假设演化过程符合某种统计模型（如 Jukes-Cantor 模型）。
- 最优树是具有最大似然值的树。

**步骤**
1. **选择演化模型**：根据数据选择合适的替换模型（如 JC69、GTR 模型）。

2. **计算似然值**：对每棵可能的树，计算观测序列给定树的概率 \( P(序列 | 树) \)。

3. **选择最优树**：
   - 选择似然值最大的树。


- **优点**：精确，适合复杂演化关系。
- **缺点**：计算量大，需要强大的计算资源。




 **2.3 贝叶斯推断（Bayesian Inference）**

**基本思想**
- 基于贝叶斯统计，通过后验概率推断最优进化树。
结合先验知识和观测数据构建树。



**步骤**
1. **设定先验分布**：设定树结构和参数的先验分布。

2. **计算后验概率**：使用贝叶斯公式：

$$
     P(树 | 数据) \propto P(数据 | 树) \cdot P(树)
$$

3. **采样搜索**：使用 Markov Chain Monte Carlo（MCMC）方法，在树空间中采样，寻找后验概率最大的树。



**优点**：
能结合先验知识，适合高度不确定的情况。
提供完整的后验概率分布。
**缺点**：计算复杂，训练时间长。


 **总结与对比**

| **算法**       | **适用场景**             | **优点**                  | **缺点**                  |
|----------------|-------------------------|---------------------------|---------------------------|
| **UPGMA**      | 进化速率一致的序列       | 简单快速                  | 对分子钟假设敏感          |
| **邻接法（NJ）**| 进化速率不一致的序列     | 适用范围广                | 对距离矩阵依赖高          |
| **最大简约法（MP）**| 小规模、低变异的序列    | 简单直观                  | 不适合高变异或长序列      |
| **最大似然法（ML）**| 复杂序列或精确分析       | 精确                      | 计算量大                  |
| **贝叶斯推断** | 高度不确定或需结合先验知识| 提供后验概率分布          | 训练时间长，计算复杂      |


## **3. 进化树的构建流程**

**序列准备**
1. 收集目标序列：
   - DNA、RNA 或蛋白质序列。
2. 进行多序列比对：
   - 使用工具如 Clustal Omega、MUSCLE 或 MAFFT 对序列进行比对，找出序列的保守区域。



**计算距离或构建模型**
1. **距离矩阵**：
   - 使用如 Jukes-Cantor（JC69）模型或 Kimura 两参数模型计算序列间的演化距离。
   - 生成成对距离矩阵。
2. **进化模型**：
   - 最大似然法需要选择合适的模型（如 GTR 模型）。



 **选择算法**
- 距离法：使用 NJ 或 UPGMA 构建进化树。
- 字符法：使用 MP 或 ML 算法。
- 贝叶斯推断：使用工具如 MrBayes。



**构建进化树**
- 使用如 MEGA 等软件，根据选择的算法构建树。



**结果可视化**
- 使用图形化工具绘制进化树，如：
  - **MEGA**：可视化并编辑进化树。




## **4. 进化树的评估与优化**

**分支支持度（Bootstrap）**
**作用**：
 评估进化树的稳定性和可靠性。

**方法**：
  - 对原始数据进行重复抽样（如 100 次），重新构建进化树。
  - 统计每个分支出现在树中的比例（支持度），高支持度表示分支可靠。





## **5. 进化树的应用**

**物种进化研究**
比较不同物种的基因组，推测其分化时间和关系。


**基因功能预测**
比对未知基因与已知基因的进化关系，预测基因的可能功能。

**疾病传播分析**
构建病毒进化树，研究疾病在不同地区和宿主间的传播路径。

**环境微生物分析**
通过 16S rRNA 序列构建进化树，研究微生物群落的组成和演化。

---

## 本文参考
《生物信息学》 樊笼江主编

